<script src='https://cdn.jsdelivr.net/g/lodash@4(lodash.min.js+lodash.fp.min.js)'></script>
<script>
// Loading `lodash.fp.js` converts `_` to its fp variant.
console.log(_.defaults({ 'a': 2, 'b': 2 })({ 'a': 1 }));
// ➜ { 'a': 1, 'b': 2 }

// Use `noConflict` to restore the pre-fp variant.
var fp = _.noConflict();

console.log(_.defaults({ 'a': 1 }, { 'a': 2, 'b': 2 }));
// ➜ { 'a': 1, 'b': 2 }
console.log(fp.defaults({ 'a': 2, 'b': 2 })({ 'a': 1 }));
// ➜ { 'a': 1, 'b': 2 }


//memoize - factorial (its a pure function w/o any side effects)
// However, its never called recursively with the same  argument
// so memoization is overkill
function factorial(num) {
  if(num === 1) { return 1 };
  console.log(num);
  return num * factorial(num - 1);
}

function fib( x ) {
    console.log('working fib... %d', x);
    if(x < 2) return 1; else return fib(x-1) + fib(x-2);
}

var fact = memoize21(factorial,function(){});
console.log(fact(10));
console.log(fact(10)); // successive calls will return precalculated value from memoization (won't see console.logs)

console.log(factorial(10));
console.log(factorial(10)); // successive calls will recalc and will see console.logs)

var fibFn = _.memoize(fib);
console.log(fibFn(5));
console.log(fibFn(5)); // successive calls will not recalc and will see console.logs)
console.log(fib(5));
console.log(fib(5)); // successive calls will recalc and will see console.logs)

//memoize an object
function memoize(func, depsFunc) {
  var cache = {};
  return function() {
    var key = JSON.stringify([depsFunc(), arguments]);
    if(cache[key]) {
      return cache[key];
    }
    else {
      var val = func.apply(this, arguments);
      cache[key] = val;
      return val;
    }
  };
}

/*
* memoize.js
* by @philogb and @addyosmani
* with further optimizations by @mathias
* and @DmitryBaranovsk
* perf tests: http://bit.ly/q3zpG3
* Released under an MIT license.
*/
function memoize2( fn ) {
    return function () {
        var args = Array.prototype.slice.call(arguments),
            hash = "",
            i = args.length;
        currentArg = null;
        while (i--) {
            currentArg = args[i];
            hash += (currentArg === Object(currentArg)) ?
            JSON.stringify(currentArg) : currentArg;
            fn.memoize || (fn.memoize = {});
        }
        return (hash in fn.memoize) ? fn.memoize[hash] :
        fn.memoize[hash] = fn.apply(this, args);
    };
}
//update memoize2 to handle Object - its perf is significantly better than memoize
function memoize21( fn, depsFunc) {
    return function () {
        var args = Array.prototype.slice.call(arguments),
            hash = "",
            currentArg = JSON.stringify([depsFunc(), arguments]);
        
        hash += (currentArg === JSON.stringify([depsFunc(), arguments])) ?
        JSON.stringify([depsFunc(), arguments]) : currentArg;
        fn.memoize || (fn.memoize = {});

        return (hash in fn.memoize) ? fn.memoize[hash] :
        fn.memoize[hash] = fn.apply(this, args);
    };
}

function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;

  this.fullName = memoize21(
    // calculation
    function(title) {
      console.log('working...');
      return title + ' ' + this.firstName + ' ' + this.lastName;
    },
    // dependencies
    function() {
      return [this.firstName, this.lastName];
    }.bind(this));
}
// create a new Person
var person = new Person('Jonathan', 'Lehman');

// first call to our memoized function does the work
console.log(person.fullName('Mr.'));
//=> working
//=> Mr. Jonathan Lehman

// successive calls
console.log(person.fullName('Mr.'));
//=> Mr. Jonathan Lehman

// work must be done if dependencies or arguments change

// change arguments
console.log(person.fullName('Mister'));
//=> work
//=> Mister Jonathan Lehman

// change deps
person.firstName = 'Jon';
console.log(person.fullName('Mr.'));
//=> work
//=> Mr. Jon Lehman
</script>